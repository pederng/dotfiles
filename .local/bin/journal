#!/usr/bin/env python
from __future__ import annotations

import sys
import subprocess
from collections import defaultdict
from dataclasses import dataclass, field
from datetime import date, datetime
from enum import Enum
from itertools import chain
from operator import attrgetter
from pathlib import Path
from pprint import pprint
from typing import Dict, List, Iterator, cast, Set, Iterable, Union, Optional

FMT = "%A %B %d %Y"
BRK = "\n"
HEADER = "# "
OPEN_TASKS = "# Open tasks"
CLOSED_TASKS = "# Closed tasks"
TASK = "* TASK: "
DONE = "(DONE)"
CANCELLED = "(CANCELLED)"
JOURNAL = Path("/home/peder/.notes/journal.md")
SPECIAL_HEADERS = [OPEN_TASKS, CLOSED_TASKS]
COMMANDS = ["tasks", "sync", "completion", "week", "grep"]
COMPLETION = f"""
__journal_completions()
{{
    COMPREPLY=( $(compgen -W "{' '.join(COMMANDS)}" "${{COMP_KEY}}") )
}}
complete -F __journal_completions journal
"""


def is_task(line: str) -> bool:
    return line.startswith(TASK)


def is_tag(word: str) -> bool:
    return word.startswith(":") and word.endswith(":")


class TaskState(Enum):
    OPEN = "open"
    DONE = "done"
    CANCELLED = "cancelled"


@dataclass
class Line:
    raw: str

    def __eq__(self, other: object) -> bool:
        if isinstance(other, Line):
            return self.raw == other.raw
        return self.raw == other


@dataclass
class Header(Line):
    date: date = field(init=False)

    def __post_init__(self) -> None:
        _, _, date_str = self.raw.partition(HEADER)
        self.date = datetime.strptime(date_str, FMT).date()

    def __eq__(self, other: object) -> bool:
        if isinstance(other, Header):
            return self.raw == other.raw
        return self.raw == other


@dataclass()
class Task(Line):
    content: str = field(init=False)
    tags: List[str] = field(init=False)
    state: TaskState = field(init=False)

    def __post_init__(self) -> None:
        self.state = TaskState.OPEN
        _, _, stripped = self.raw.partition(TASK)
        stripped, done, _ = stripped.partition(DONE)
        stripped, cancelled, _ = stripped.partition(CANCELLED)
        assert not (done and cancelled)
        if done:
            self.state = TaskState.DONE
        if cancelled:
            self.state = TaskState.CANCELLED
        self.tags = list(map(lambda t: t.strip(":"), filter(is_tag, stripped.split())))
        for tag in self.tags:
            stripped = stripped.replace(tag, "")
        self.content = stripped.strip()

    @property
    def is_open(self) -> bool:
        return self.state == TaskState.OPEN

    @property
    def is_closed(self) -> bool:
        return not self.is_open

    def __hash__(self) -> int:
        return hash(self.content)


def header(content: str) -> str:
    return f"# {content}"


def header_iter(content: str) -> Iterator[str]:
    yield header(content) + BRK
    yield BRK


def skip_consecutive_empty_lines(lines: Iterator[str]) -> Iterator[str]:
    prev = None
    for line in lines:
        if prev and (prev, line) == (BRK, BRK):
            continue
        yield line
        prev = line


def raw_line_iter(lines: Iterable[Line]) -> Iterator[str]:
    for line in lines:
        yield line.raw + BRK


class Journal:
    def __init__(self) -> None:
        self._content: List[Line] = []
        self._tasks: List[Task] = []
        self._headers: List[Header] = []
        self._days: Dict[date, List[Line]] = defaultdict(list)

    def _add(self, line: Union[Line, Task], date: Optional[date] = None) -> None:
        if isinstance(line, Task):
            if line in self._tasks:
                self._tasks.remove(line)
            return self._tasks.append(line)
        if isinstance(line, Header):
            self._headers.append(line)
        elif date and line.raw:
            self._days[date].append(line)
        return self._content.append(line)

    def _read(self, lines: Iterator[str]) -> None:
        current_date = None
        for line in lines:
            if line in SPECIAL_HEADERS:
                continue
            line_: Line
            if is_task(line):
                line_ = Task(line)
            elif line.startswith(HEADER):
                line_ = Header(line)
                current_date = line_.date
            else:
                line_ = Line(line)
            self._add(line_, current_date)

    def _add_date_header(self) -> None:
        date_header = "".join(header(date.today().strftime(FMT)))
        if date_header in self._headers:
            return
        self._add(Header(date_header))
        self._add(Line(""))

    @classmethod
    def read(cls) -> Journal:
        journal = cls()
        with open(JOURNAL, "r") as file:
            journal._read(map(lambda l: l.strip("\n"), file))
        journal._add_date_header()
        return journal

    @property
    def _raw_lines(self) -> Iterator[str]:
        yield from chain(
            header_iter("Closed tasks"),
            raw_line_iter(self.closed_tasks),
            raw_line_iter(self._content),
            header_iter("Open tasks"),
            raw_line_iter(self.open_tasks),
        )

    @property
    def raw_lines(self) -> Iterator[str]:
        yield from skip_consecutive_empty_lines(self._raw_lines)

    @property
    def tasks(self) -> Iterator[Task]:
        for task in self._tasks:
            yield task

    @property
    def open_tasks(self) -> Iterator[Task]:
        yield from filter(attrgetter("is_open"), self.tasks)

    @property
    def closed_tasks(self) -> Iterator[Task]:
        yield from filter(attrgetter("is_closed"), self.tasks)


def edit() -> None:
    subprocess.run([f"vim", "+$", f"{JOURNAL}"])


def write(journal: Journal) -> None:
    with JOURNAL.open("w") as f:
        for line in journal.raw_lines:
            f.write(line)


def list_tasks(tags: List[str]) -> None:
    tasks: List[Task] = []
    for task in Journal.read().open_tasks:
        if tags and not any(t in task.tags for t in tags):
            continue
        print(task.raw)


def default() -> None:
    journal = Journal.read()
    write(journal)
    edit()


if __name__ == "__main__":
    if len(sys.argv) == 1:
        default()
        sys.exit(0)
    cmd = sys.argv[1]
    if cmd not in COMMANDS:
        raise RuntimeError(f"Unknown command {cmd}")
    if cmd == "tasks":
        list_tasks(sys.argv[2:])
    elif cmd == "sync":
        subprocess.run(["notes", "sync"])
    elif cmd == "completion":
        print(COMPLETION)
