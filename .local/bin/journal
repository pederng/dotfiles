#!/usr/bin/env python
from __future__ import annotations

import sys
import subprocess
from dataclasses import dataclass, field
from datetime import datetime
from enum import Enum
from itertools import chain
from operator import attrgetter
from pathlib import Path
from pprint import pprint
from typing import Dict, List, Iterator, cast, Set, Iterable

FMT = "%A %B %d %Y"
BRK = "\n"
HEADER = "# "
OPEN_TASKS = "## Open tasks"
CLOSED_TASKS = "## Closed tasks"
TASK = "* TASK: "
DONE = "(DONE)"
CANCELLED = "(CANCELLED)"
JOURNAL = Path("/home/peder/.notes/journal.md")

COMMANDS = ["tasks", "sync", "completion"]
COMPLETION = f"""
__journal_completions()
{{
    COMPREPLY=( $(compgen -W "{' '.join(COMMANDS)}" "${{COMP_KEY}}") )
}}
complete -F __journal_completions journal
"""


def is_task(line: str) -> bool:
    return line.startswith(TASK)


def is_tag(word: str) -> bool:
    return word.startswith(":") and word.endswith(":")


class TaskState(Enum):
    OPEN = "open"
    DONE = "done"
    CANCELLED = "cancelled"


@dataclass
class Line:
    raw: str

    def __eq__(self, other: object) -> bool:
        if isinstance(other, Line):
            return self.raw == other.raw
        return self.raw == other


@dataclass
class Header(Line):
    def __eq__(self, other: object) -> bool:
        if isinstance(other, Header):
            return self.raw == other.raw
        return self.raw == other


@dataclass()
class Task(Line):
    content: str = field(init=False)
    tags: List[str] = field(init=False)
    state: TaskState = field(init=False)

    def __post_init__(self) -> None:
        self.state = TaskState.OPEN
        _, _, stripped = self.raw.partition(TASK)
        stripped, done, _ = stripped.partition(DONE)
        stripped, cancelled, _ = stripped.partition(CANCELLED)
        assert not (done and cancelled)
        if done:
            self.state = TaskState.DONE
        if cancelled:
            self.state = TaskState.CANCELLED
        self.tags = list(map(lambda t: t.strip(":"), filter(is_tag, stripped.split())))
        for tag in self.tags:
            stripped = stripped.replace(tag, "")
        self.content = stripped.strip()

    @property
    def is_open(self) -> bool:
        return self.state == TaskState.OPEN

    @property
    def is_closed(self) -> bool:
        return not self.is_open

    def __hash__(self) -> int:
        return hash(self.content)


def sub_header(content: str) -> Iterator[str]:
    yield f"## {content}{BRK}"
    yield BRK


def skip_consecutive_empty_lines(lines: Iterator[str]) -> Iterator[str]:
    prev = None
    for line in lines:
        if prev and (prev, line) == (BRK, BRK):
            continue
        yield line
        prev = line


def raw_line_iter(lines: Iterable[Line]) -> Iterator[str]:
    for line in lines:
        yield line.raw + BRK


class Journal:
    def __init__(self) -> None:
        self._content: List[Line] = []
        self._tasks: Set[Task] = set()
        self._headers: List[Header] = []

    def _add(self, line: str) -> None:
        if line in [OPEN_TASKS, CLOSED_TASKS]:
            return
        if is_task(line):
            task = Task(line)
            if task in self._tasks:
                self._tasks.remove(task)
            return self._tasks.add(task)
        if line.startswith(HEADER):
            line_: Line = Header(line)
            self._headers.append(cast(Header, line_))
        else:
            line_ = Line(line)
        return self._content.append(line_)

    def _add_latest_header(self) -> None:
        header = f"{HEADER}{datetime.now().strftime(FMT)}"
        size = len(self._content)
        if header in self._headers:
            return
        self._add(header)
        self._add("")

    @classmethod
    def read(cls) -> Journal:
        journal = cls()
        for line in JOURNAL.read_text().split("\n"):
            journal._add(line)
        journal._add_latest_header()
        return journal

    @property
    def _raw_lines(self) -> Iterator[str]:
        yield from chain(
            sub_header("Closed tasks"),
            raw_line_iter(self.closed_tasks),
            raw_line_iter(self._content),
            sub_header("Open tasks"),
            raw_line_iter(self.open_tasks),
        )

    @property
    def raw_lines(self) -> Iterator[str]:
        yield from skip_consecutive_empty_lines(self._raw_lines)

    @property
    def tasks(self) -> Iterator[Task]:
        for task in self._tasks:
            yield task

    @property
    def open_tasks(self) -> Iterator[Task]:
        yield from filter(attrgetter("is_open"), self.tasks)

    @property
    def closed_tasks(self) -> Iterator[Task]:
        yield from filter(attrgetter("is_closed"), self.tasks)


def edit() -> None:
    subprocess.run([f"vim", "+$", f"{JOURNAL}"])


def write(journal: Journal) -> None:
    with JOURNAL.open("w") as f:
        for line in journal.raw_lines:
            f.write(line)


def list_tasks(tags: List[str]) -> None:
    tasks: List[Task] = []
    for task in Journal.read().open_tasks:
        print(task.raw)


def default() -> None:
    journal = Journal.read()
    write(journal)
    edit()


if __name__ == "__main__":
    if len(sys.argv) == 1:
        default()
        sys.exit(0)
    cmd = sys.argv[1]
    if cmd not in COMMANDS:
        raise RuntimeError(f"Unknown command {cmd}")
    if cmd == "tasks":
        list_tasks(sys.argv[2:])
    elif cmd == "sync":
        subprocess.run(["notes", "sync"])
    elif cmd == "completion":
        print(COMPLETION)
