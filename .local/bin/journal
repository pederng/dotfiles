#!/usr/bin/env python
from __future__ import annotations
import sys
from enum import Enum
from itertools import chain
from pprint import pprint
from typing import Dict, List, Iterator
from pathlib import Path
from datetime import datetime
from dataclasses import dataclass, field, asdict
import subprocess

FMT = "%A %B %d %Y"
BRK = "\n"
HEADER = "#"
TASK = "* TASK: "
DONE = "(DONE)"
CANCELLED = "(CANCELLED)"
JOURNAL = Path("/home/peder/.notes/journal.md")

COMMANDS = ["tasks", "sync", "completion"]
COMPLETION = f"""
__journal_completions()
{{
    COMPREPLY=( $(compgen -W "{' '.join(COMMANDS)}" "${{COMP_KEY}}") )
}}
complete -F __journal_completions journal
"""


def is_task(line: str) -> bool:
    return line.startswith(TASK)


def is_closed(line: str) -> bool:
    if not is_task(line):
        return False
    return line.endswith(DONE) or line.endswith(CANCELLED)


def is_open_task(line: str) -> bool:
    return is_task(line) and not is_closed(line)


def is_tag(word: str) -> bool:
    return word.startswith(":") and word.endswith(":")


class TaskState(Enum):
    OPEN = "open"
    DONE = "done"
    CANCELLED = "cancelled"


@dataclass()
class Task:
    raw: str
    content: str = field(init=False)
    tags: List[str] = field(init=False)
    state: TaskState = field(init=False)

    def __post_init__(self) -> None:
        self.state = TaskState.OPEN
        _, _, stripped = self.raw.partition(TASK)
        stripped, done, _ = stripped.partition(DONE)
        stripped, cancelled, _ = stripped.partition(CANCELLED)
        assert not (done and cancelled)
        if done:
            self.state = TaskState.DONE
        if cancelled:
            self.state = TaskState.CANCELLED
        self.tags = list(map(lambda t: t.strip(":"), filter(is_tag, stripped.split())))
        for tag in self.tags:
            stripped = stripped.replace(tag, "")
        self.content = stripped.strip()

    @property
    def is_open(self) -> bool:
        return self.state == TaskState.OPEN

    @property
    def is_closed(self) -> bool:
        return not self.is_open

    def __hash__(self) -> int:
        return hash(self.content)

    def __eq__(self, other: object) -> bool:
        if not isinstance(other, Task):
            raise ValueError("object is not a Task")
        return self.content == other.content


@dataclass
class Entry:
    loc: int
    date: datetime
    content: List[str] = field(default_factory=list)

    def __iter__(self) -> Iterator[str]:
        return iter(self.content)

    def has_task(self, task: Task) -> bool:
        return task in self.tasks

    def _filter_iter(self, pred) -> Iterator[str]:
        for line in self:
            if pred(line):
                yield line

    @property
    def tasks(self) -> Iterator[Task]:
        return map(Task, self._filter_iter(is_task))

    @property
    def open_tasks(self) -> Iterator[Task]:
        return map(Task, self._filter_iter(is_open_task))


Entries = Dict[str, Entry]


def add_latest_header() -> None:
    header = f"{HEADER} {datetime.now().strftime(FMT)}"
    if JOURNAL.exists():
        content = JOURNAL.read_text()
        if header in content:
            return
        header = f"{BRK if content else ''}{header}{BRK}{BRK}"
    with JOURNAL.open("a" if JOURNAL.exists() else "w") as f:
        f.write(header)


def edit() -> None:
    subprocess.run([f"vim", "+$", f"{JOURNAL}"])


def write(entries: Entries) -> None:
    with JOURNAL.open("w") as f:
        for line in chain(*entries.values()):
            f.write(line + BRK)


def remove_final_newline(entries: Entries) -> Entries:
    last_entry = list(entries.values())[-1]
    if not last_entry.content[-1]:
        last_entry.content = last_entry.content[:-1]
    return entries


def get_entries() -> Entries:
    entries: Entries = {}
    for line_no, line in enumerate(JOURNAL.read_text().split("\n")):
        if line.startswith(HEADER):
            _, _, date_str = line.partition(" ")
            entries[date_str] = Entry(line_no, datetime.strptime(date_str, FMT))
        entries[date_str].content.append(line)
    return remove_final_newline(entries)


def bump_tasks(entries: Entries) -> Entries:
    if len(entries) == 1:
        return entries
    previous, current = list(entries.values())[-2:]
    for task in previous.open_tasks:
        if not current.has_task(task):
            current.content.append(task.raw)
    return entries


def list_tasks(tags: List[str]) -> None:
    tasks: List[Task] = []
    for task in chain(*(e.tasks for e in get_entries().values())):
        if task in tasks:
            tasks.remove(task)
        tasks.append(task)
    for task in tasks:
        if task.is_closed:
            continue
        if tags and not all(t in task.tags for t in tags):
            continue
        print(task.raw)


def default() -> None:
    add_latest_header()
    write(bump_tasks(get_entries()))
    edit()


if __name__ == "__main__":
    if len(sys.argv) == 1:
        default()
        sys.exit(0)
    cmd = sys.argv[1]
    if cmd not in COMMANDS:
        raise RuntimeError(f"Unknown command {cmd}")
    if cmd == "tasks":
        list_tasks(sys.argv[2:])
    elif cmd == "sync":
        subprocess.run(["notes", "sync"])
    elif cmd == "completion":
        print(COMPLETION)
