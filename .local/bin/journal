#!/usr/bin/env python
from __future__ import annotations
import sys
from enum import Enum
from operator import attrgetter
from itertools import chain
from pprint import pprint
from typing import Dict, List, Iterator, Protocol, cast, runtime_checkable
from pathlib import Path
from datetime import datetime
from dataclasses import dataclass, field, asdict
import subprocess

FMT = "%A %B %d %Y"
BRK = "\n"
HEADER = "#"
TASK = "* TASK: "
DONE = "(DONE)"
CANCELLED = "(CANCELLED)"
JOURNAL = Path("/home/peder/.notes/journal.md")

COMMANDS = ["tasks", "sync", "completion"]
COMPLETION = f"""
__journal_completions()
{{
    COMPREPLY=( $(compgen -W "{' '.join(COMMANDS)}" "${{COMP_KEY}}") )
}}
complete -F __journal_completions journal
"""


def is_task(line: str) -> bool:
    return line.startswith(TASK)


def is_tag(word: str) -> bool:
    return word.startswith(":") and word.endswith(":")


class TaskState(Enum):
    OPEN = "open"
    DONE = "done"
    CANCELLED = "cancelled"


@runtime_checkable
class LineP(Protocol):
    @property
    def raw(self) -> str:
        ...

    @property
    def line_no(self) -> int:
        ...


@dataclass
class Header:
    raw: str
    line_no: int

    def __eq__(self, other: object) -> bool:
        if isinstance(other, LineP):
            return self.raw == other.raw
        return self.raw == other


@dataclass
class Line:
    raw: str
    line_no: int

    def __eq__(self, other: object) -> bool:
        if isinstance(other, LineP):
            return self.raw == other.raw
        return self.raw == other


@dataclass()
class Task:
    raw: str
    line_no: int
    content: str = field(init=False)
    tags: List[str] = field(init=False)
    state: TaskState = field(init=False)

    def __post_init__(self) -> None:
        self.state = TaskState.OPEN
        _, _, stripped = self.raw.partition(TASK)
        stripped, done, _ = stripped.partition(DONE)
        stripped, cancelled, _ = stripped.partition(CANCELLED)
        assert not (done and cancelled)
        if done:
            self.state = TaskState.DONE
        if cancelled:
            self.state = TaskState.CANCELLED
        self.tags = list(map(lambda t: t.strip(":"), filter(is_tag, stripped.split())))
        for tag in self.tags:
            stripped = stripped.replace(tag, "")
        self.content = stripped.strip()

    @property
    def is_open(self) -> bool:
        return self.state == TaskState.OPEN

    @property
    def is_closed(self) -> bool:
        return not self.is_open

    def __hash__(self) -> int:
        return hash(self.content)

    def __eq__(self, other: object) -> bool:
        if not isinstance(other, Task):
            return False
        return self.content == other.content


class Journal:
    def __init__(self) -> None:
        self._content: List[LineP] = []
        self._tasks: List[Task] = []
        self._headers: List[Header] = []
        self._size = -1

    @property
    def size(self) -> int:
        return self._size

    def add(self, line: str) -> None:
        self._size += 1
        line_no = self.size
        if is_task(line):
            line_: LineP = Task(line, line_no)
            self._tasks.append(cast(Task, line_))
        elif line.startswith(HEADER):
            line_ = Header(line, line_no)
            self._headers.append(line_)
        else:
            line_ = Line(line, line_no)
        return self._content.append(line_)

    @property
    def raw_lines(self) -> Iterator[str]:
        size = len(self._content)
        for idx, line in enumerate(self._content):
            if idx == size - 1:
                yield line.raw
            else:
                yield line.raw + BRK

    @property
    def tasks(self) -> Iterator[Task]:
        for task in self._tasks:
            yield task

    def _add_latest_header(self) -> None:
        header = f"{HEADER} {datetime.now().strftime(FMT)}"
        size = len(self._content)
        if header in self._headers:
            return
        self.add(header)
        self.add("")

    def bump(self) -> None:
        self._add_latest_header()
        if len(self._headers) == 1:
            return
        previous_header_line = self._headers[-2].line_no
        last_header_line = self._headers[-1].line_no
        tasks = filter(
            lambda t: t not in filter(lambda t: t.line_no > last_header_line, self.tasks),
            filter(
                attrgetter("is_open"),
                filter(lambda t: previous_header_line < t.line_no < last_header_line, self.tasks),
            ),
        )
        for task in list(tasks):  # evaluate it to avoid endless looping when adding new tasks
            self.add(task.raw)


def edit() -> None:
    subprocess.run([f"vim", "+$", f"{JOURNAL}"])


def read() -> Journal:
    journal = Journal()
    for line in JOURNAL.read_text().split("\n"):
        journal.add(line)
    return journal


def write(journal: Journal) -> None:
    with JOURNAL.open("w") as f:
        for line in journal.raw_lines:
            f.write(line)


def list_tasks(tags: List[str]) -> None:
    tasks: List[Task] = []
    for task in read().tasks:
        if task in tasks:
            tasks.remove(task)
        tasks.append(task)
    for task in tasks:
        if task.is_closed:
            continue
        if tags and not all(t in task.tags for t in tags):
            continue
        print(task.raw)


def default() -> None:
    journal = read()
    journal.bump()
    write(journal)
    edit()


if __name__ == "__main__":
    if len(sys.argv) == 1:
        default()
        sys.exit(0)
    cmd = sys.argv[1]
    if cmd not in COMMANDS:
        raise RuntimeError(f"Unknown command {cmd}")
    if cmd == "tasks":
        list_tasks(sys.argv[2:])
    elif cmd == "sync":
        subprocess.run(["notes", "sync"])
    elif cmd == "completion":
        print(COMPLETION)
